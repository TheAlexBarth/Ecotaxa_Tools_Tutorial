[
  {
    "objectID": "export_UVP_ecopart-export.html",
    "href": "export_UVP_ecopart-export.html",
    "title": "Exporting Ecopart Data",
    "section": "",
    "text": "You can always export ecopart data directly from Ecotaxa. This is how you would do it for zooscan, planktoscope, etc. However, the UVP requires access to the particle datafiles as well to calculate volume sampled in 1m bins. Exporting through ecopart will export all the files from a given project in one convenient directory."
  },
  {
    "objectID": "export_UVP_ecopart-export.html#accessing-data-on-ecopart",
    "href": "export_UVP_ecopart-export.html#accessing-data-on-ecopart",
    "title": "Exporting Ecopart Data",
    "section": "Accessing data on Ecopart:",
    "text": "Accessing data on Ecopart:\n\nGo to the ecopart website.\nSelect your project or set filters to a desired range of casts\n\nOnce projects are selected, select “export selection.\nThen Select “RAW”\n\nThis will put all the files in a .zip\nExtract those files and put them in a directory that you have access to.\n\n\n  \n    \n      Importing Data from Ecopart"
  },
  {
    "objectID": "gen_bin-taxa.html",
    "href": "gen_bin-taxa.html",
    "title": "bin_taxa()",
    "section": "",
    "text": "To organize count data from a zoo_df by taxanomic categories, bin_taxa() is the way to go. This is the engine behind uvp_zoo_conc(). In it’s current configuration, bin_taxa() is intended for binning by taxa into specified depth-bins. However, it’s future use should allow for binning by season, location, or other categories. Under the current configuraiton, the zooscan option will allow for alternative binning, it might just require some hard-coding."
  },
  {
    "objectID": "gen_bin-taxa.html#main-functionality",
    "href": "gen_bin-taxa.html#main-functionality",
    "title": "bin_taxa()",
    "section": "Main Functionality:",
    "text": "Main Functionality:\nThe main argument needed to provide is a zoo_df and an argument for depth_breaks. This is a character vector of the limits for each depth bin. For example, to distinguish the epipelagic and the mesopelagic, you can set depth_breaks = c(0,200,1200). By default, bin_by() will identify each unique taxa by the $name or $object_annotation_category column and return the count of each label in each bin. Other columns can be specified with the cat_col argument if there another column to aggregate by (ex an alternative name). Additionally, while the main use of bin_taxa() is to count the number of observations in each bin, it can be used with other functions. The func and func_col can be used to specify what other columns to apply the function to. For an example look at its application in the uvp example"
  },
  {
    "objectID": "gen_bin-taxa.html#use-with-uvp",
    "href": "gen_bin-taxa.html#use-with-uvp",
    "title": "bin_taxa()",
    "section": "Use with UVP:",
    "text": "Use with UVP:\nTo use bin_taxa() with UVP data, it is best to go through uvp_zoo_conc(). However, it is possible to use bin_taxa() with a single zoo_df. One consideration with the UVP is that if there are no observations in a depth-bin you must set force_bins = TRUE. This isn’t an issue for net samples. However, it can be an issue with the UVP because it may sample a bin with nothing in it. Likely that is if bins are too small. Nonetheless, this is already accounted for in uvp_zoo_conc()."
  },
  {
    "objectID": "gen_bin-taxa.html#use-with-zooscan",
    "href": "gen_bin-taxa.html#use-with-zooscan",
    "title": "bin_taxa()",
    "section": "Use with Zooscan:",
    "text": "Use with Zooscan:\nCurrently, the zooscan configuration will simply bin based on unique sample_id columns. Thus, it is important to be considerate of what the sample_id’s indicate. To use, simply set zooscan = T and it will return counts aggregated by sample_id."
  },
  {
    "objectID": "gen_biovolume.html",
    "href": "gen_biovolume.html",
    "title": "biovolume()",
    "section": "",
    "text": "library(EcotaxaTools)\nzoo_df <- ecopart_example$zoo_files[[1]]\nbiovol <- biovolume(input = zoo_df,\n                    shape = 'ellipsoid',\n                    pixel_mm = unique(ecopart_example$meta$acq_pixel))\n\nbiovol |> summary()\n\n   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. \n 0.1929  0.4379  0.5601  0.8353  0.7980 90.8001"
  },
  {
    "objectID": "gen_rel-taxa.html",
    "href": "gen_rel-taxa.html",
    "title": "Relative Abundance",
    "section": "",
    "text": "rel_taxa() provides a quick way to get relative abundance based solely off observations. Note this approach does not consider the volume sampled in acquiring observations. To get a better quantitative estimate, use uvp_zoo_conc(). This function will work either for a single zoo_df for multiple provided as either a zoo_list or ecopart_obj."
  },
  {
    "objectID": "gen_rel-taxa.html#for-multiple-casts",
    "href": "gen_rel-taxa.html#for-multiple-casts",
    "title": "Relative Abundance",
    "section": "For multiple casts:",
    "text": "For multiple casts:\nTo get the relative abundance of all living categories:\n\nlibrary(EcotaxaTools)\nrel_data <- ecopart_example |> \n    mod_zoo(names_drop, drop_names = 'not-living', drop_children = T) |>\n    add_zoo(names_to, col_name = 'name', new_names = c('Rhizaria', 'Copepoda', 'Chaetognatha', 'Eumalacostraca', 'living',\n                                                       'Trichodesmium'), suppress_print = T) |>\n    rel_taxa()\n# this produces a list for all casts with df of relative abundance\n# Single list element:\nrel_data[[1]]\n\n# A tibble: 6 × 2\n  taxa           rel_abundance\n  <chr>                  <dbl>\n1 Chaetognatha          0.0588\n2 Copepoda              0.118 \n3 Eumalacostraca        0.206 \n4 living                0.0294\n5 Rhizaria              0.309 \n6 Trichodesmium         0.279"
  },
  {
    "objectID": "gen_rel-taxa.html#across-all-observations",
    "href": "gen_rel-taxa.html#across-all-observations",
    "title": "Relative Abundance",
    "section": "Across all observations:",
    "text": "Across all observations:\nZooplankton data are stored in individual zoo_df by each cast. So to quickly visualize the relative abundance across all casts, casts must be combined into one. This is best done with merge_casts():\n\nname_map = list(\n    all_casts = ecopart_example$meta$profileid\n)\n\nrel_data <- ecopart_example |>\n    merge_casts(name_map = name_map) |>\n    rel_taxa()\n\nhead(rel_data$all_casts, 15)\n\n# A tibble: 15 × 2\n   taxa              rel_abundance\n   <chr>                     <dbl>\n 1 Acantharea            0.00591  \n 2 Actinopterygii        0.000279 \n 3 Alciopidae            0.000559 \n 4 Annelida              0.0000399\n 5 artefact              0.0000399\n 6 Aulacantha            0.00303  \n 7 Aulacanthidae         0.00204  \n 8 Aulatractus           0.0000399\n 9 Aulosphaeridae        0.00339  \n10 badfocus<artefact     0.337    \n11 bubble                0.000599 \n12 Cannosphaeridae       0.0000399\n13 Castanellidae         0.00184  \n14 Chaetognatha          0.00196  \n15 Cnidaria<Hydrozoa     0.000279"
  },
  {
    "objectID": "help_list-to-tib.html",
    "href": "help_list-to-tib.html",
    "title": "list_to_tib()",
    "section": "",
    "text": "library(EcotaxaTools)\necopart_example$zoo_files |> list_to_tib('cast')\n\n# A tibble: 25,054 × 91\n   orig_id    objid name  taxo_hierarchy classif_qual depth_including… psampleid\n   <chr>      <dbl> <chr> <chr>          <chr>                   <dbl>     <dbl>\n 1 bats361_… 1.46e8 detr… not-living>de… V                        54       33963\n 2 bats361_… 1.46e8 detr… not-living>de… V                        43.4     33963\n 3 bats361_… 1.46e8 detr… not-living>de… V                        52.1     33963\n 4 bats361_… 1.46e8 detr… not-living>de… V                        23.4     33963\n 5 bats361_… 1.46e8 detr… not-living>de… V                        53.3     33963\n 6 bats361_… 1.46e8 detr… not-living>de… V                        74.7     33963\n 7 bats361_… 1.46e8 badf… not-living>ar… V                        70.4     33963\n 8 bats361_… 1.46e8 badf… not-living>ar… V                        42.5     33963\n 9 bats361_… 1.46e8 detr… not-living>de… V                        57.1     33963\n10 bats361_… 1.46e8 detr… not-living>de… V                        83.1     33963\n# … with 25,044 more rows, and 84 more variables: `%area` <dbl>, angle <dbl>,\n#   area <dbl>, area_exc <dbl>, areai <dbl>, bx <dbl>, by <dbl>, cdexc <dbl>,\n#   centroids <dbl>, circ. <dbl>, circex <dbl>, compentropy <dbl>,\n#   compm1 <dbl>, compm2 <dbl>, compm3 <dbl>, compmean <dbl>, compslope <dbl>,\n#   convarea <dbl>, convarea_area <dbl>, convperim <dbl>,\n#   convperim_perim <dbl>, cv <dbl>, elongation <dbl>, esd <dbl>, fcons <dbl>,\n#   feret <dbl>, feretareaexc <dbl>, fractal <dbl>, height <dbl>, …"
  },
  {
    "objectID": "import_UVP_ecopart_import.html",
    "href": "import_UVP_ecopart_import.html",
    "title": "Importing UVP Data From Ecopart Export",
    "section": "",
    "text": "The first step to importing ecopart data is to guarantee that you exported the data correctly from ecopart. Follow those instructions here.\nThe next step is to import your into R for analysis.\nThe exported files should all be in a single directory: \nFor this tutorial, I provided data in the package from AE1917. This is intended for examples only and not for research use. This data is stored as ecopart_example and is available throught the package\n\nImporting the data:\n\nUsing the r function ecopart_import() assign the one argument of a path to the directory of your files\nAssign the files to a list object. By using ecopart_import(), the imported files will be an ecopart_obj class structure. This class structure is defined by having three elements; (1) a par_list which has multiple par_df files; (2) a zoo_list which has multiple zoo_df files\n\n\ndir_path <- system.file('extdata','ae1917_example-data', \n                       package = 'EcotaxaTools') #This should be your directory location\necopart_list <- ecopart_import(dir_path) #load files\n\nWarning in names(par_files) != names(zoo_files): longer object length is not a\nmultiple of shorter object length\n\n\nWarning in ecopart_import(dir_path): The par_files and zoo_files don't exactly\nmatch\n\n\n\nThis will create a three element list which can be used in analysis built into EcotaxaTools. This object is an ecopart_obj class. Review the class system here\n\n“par_files” - a list of tibbles with each particle file\n“zoo_files” - a list of tibbles with each plankton image file (classic tsv)\n“meta” - a tibble with the meta\n\n\n\n\nUnderstanding the ecopart file list\nIf you are new to working with lists, it’s worth reading a bit about them. While lists can be clunky, it allows for looping over large amounts of data stored in memory.\nBelow, I’ll briefly show how to interact with some of the data stored in the ecopart list\n\nLooking at zooplankton data\nZooplankton data are stored in tibbles in the list “zoo_files”. You can access elements of a list using the $ operator or by indexing the ‘bare’ elements with [[ index operator. The names of the zoo_files correspond to the particular casts of a project.\n\n#all below with index the names files\nnames(ecopart_list$zoo_files)\n\n [1] \"bats361_ctd1\"  \"bats361_ctd2\"  \"bats361_ctd3\"  \"bats361_ctd4\" \n [5] \"bats361_ctd5\"  \"bats361_ctd6\"  \"bats361_ctd7\"  \"bats361_ctd8\" \n [9] \"bats361_ctd9\"  \"bats361_ctd12\" \"bats361_ctd13\" \"bats361_ctd14\"\n[13] \"bats361_ctd15\" \"bats361_ctd16\" \"bats361_ctd17\" \"bats361_ctd19\"\n[17] \"bats361_ctd20\" \"bats361_ctd21\" \"bats361_ctd22\" \"bats361_ctd23\"\n[21] \"bats361_ctd24\" \"bats361_ctd25\" \"bats361_ctd26\" \"bats361_ctd27\"\n\nnames(ecopart_list[[\"zoo_files\"]])\n\n [1] \"bats361_ctd1\"  \"bats361_ctd2\"  \"bats361_ctd3\"  \"bats361_ctd4\" \n [5] \"bats361_ctd5\"  \"bats361_ctd6\"  \"bats361_ctd7\"  \"bats361_ctd8\" \n [9] \"bats361_ctd9\"  \"bats361_ctd12\" \"bats361_ctd13\" \"bats361_ctd14\"\n[13] \"bats361_ctd15\" \"bats361_ctd16\" \"bats361_ctd17\" \"bats361_ctd19\"\n[17] \"bats361_ctd20\" \"bats361_ctd21\" \"bats361_ctd22\" \"bats361_ctd23\"\n[21] \"bats361_ctd24\" \"bats361_ctd25\" \"bats361_ctd26\" \"bats361_ctd27\"\n\nnames(ecopart_list[[2]])\n\n [1] \"bats361_ctd1\"  \"bats361_ctd2\"  \"bats361_ctd3\"  \"bats361_ctd4\" \n [5] \"bats361_ctd5\"  \"bats361_ctd6\"  \"bats361_ctd7\"  \"bats361_ctd8\" \n [9] \"bats361_ctd9\"  \"bats361_ctd12\" \"bats361_ctd13\" \"bats361_ctd14\"\n[13] \"bats361_ctd15\" \"bats361_ctd16\" \"bats361_ctd17\" \"bats361_ctd19\"\n[17] \"bats361_ctd20\" \"bats361_ctd21\" \"bats361_ctd22\" \"bats361_ctd23\"\n[21] \"bats361_ctd24\" \"bats361_ctd25\" \"bats361_ctd26\" \"bats361_ctd27\"\n\n\nEach zooplankton tibble has data from all vignettes collected from an individual uvp cast. You can access these in multiple ways with either the $ operator or [[ operators. These are very similar to the export data from standard Ecotaxa .tsv files. However, in an ecopart_obj, the metadata is stored separated (in the meta file). Not to worry, most EcotaxaTools functions will handle the metadata independently!\n\necopart_list$zoo_files[[3]]\n\n# A tibble: 626 × 90\n   orig_id    objid name  taxo_hierarchy classif_qual depth_including… psampleid\n   <chr>      <dbl> <chr> <chr>          <chr>                   <dbl>     <dbl>\n 1 bats361_… 1.46e8 detr… not-living>de… V                       619.      33981\n 2 bats361_… 1.46e8 Aulo… living>Eukary… V                       379.      33981\n 3 bats361_… 1.46e8 badf… not-living>ar… V                        54.1     33981\n 4 bats361_… 1.46e8 Aulo… living>Eukary… V                       420.      33981\n 5 bats361_… 1.46e8 tuff  living>Bacter… V                       104.      33981\n 6 bats361_… 1.46e8 fibe… not-living>de… V                       124.      33981\n 7 bats361_… 1.46e8 detr… not-living>de… V                       117.      33981\n 8 bats361_… 1.46e8 badf… not-living>ar… V                       115.      33981\n 9 bats361_… 1.46e8 Aula… living>Eukary… V                       543.      33981\n10 bats361_… 1.46e8 detr… not-living>de… V                       282.      33981\n# … with 616 more rows, and 83 more variables: `%area` <dbl>, angle <dbl>,\n#   area <dbl>, area_exc <dbl>, areai <dbl>, bx <dbl>, by <dbl>, cdexc <dbl>,\n#   centroids <dbl>, circ. <dbl>, circex <dbl>, compentropy <dbl>,\n#   compm1 <dbl>, compm2 <dbl>, compm3 <dbl>, compmean <dbl>, compslope <dbl>,\n#   convarea <dbl>, convarea_area <dbl>, convperim <dbl>,\n#   convperim_perim <dbl>, cv <dbl>, elongation <dbl>, esd <dbl>, fcons <dbl>,\n#   feret <dbl>, feretareaexc <dbl>, fractal <dbl>, height <dbl>, …\n\n\n\n\nLooking at particle data\nParticle data are stored in par_df tibbles for each cast. For a project, they will all be stored in the par_files element of the ecopart_obj list. Similar to the zoo_files, the names of the par_files correspond to the individual casts.\nA single par_df has 7 columns. The data here are presented in 1-m aggregate bins. Each row then is a 1-m depth bin with information about a single particle size class. Here are columns explained in detail: - The ‘depth’ column indicates the depth bin - The ‘imgcount’ column is the number of images taken in that depth bin (this is needed for volume sampled calculations) - The ‘area’ column indicates particle size as area of pixels - The ‘nbr’ column indicates the number of particles in that depth bin of that size class - The three greylimit columns correspond to the mean grey values of those particles.\n\necopart_list$par_files[[1]]\n\n# A tibble: 17,385 × 7\n   depth imgcount  area   nbr greylimit1 greylimit2 greylimit3\n   <dbl>    <dbl> <dbl> <dbl>      <dbl>      <dbl>      <dbl>\n 1     3       70    26    31          9         22         41\n 2     3       70    22    46         12         25         44\n 3     3       70    21    54         11         17         31\n 4     3       70    17    94         12         22         40\n 5     3       70    16   104         13         23         36\n 6     3       70    15   139         12         23         32\n 7     3       70    14   154         12         23         35\n 8     3       70    13   218         11         18         29\n 9     3       70    12   309         11         19         29\n10     3       70    11   375         12         19         30\n# … with 17,375 more rows\n\n\nLearn more about how to process particle concentration data here"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Ecotaxa Tools Guide",
    "section": "",
    "text": "EcotaxaTools is an R package I developed to easily manage and analyze output from the ecotaxa website. Check out the github page for EcotaxaTools here.\nThe project is under current development so check back frequently. You can read the updates tab for new information here.\nThe current build (ver 1.2.0.9000) is primarily for UVP and ecopart data processing. However, there is some functionality which will be useful with the zoo_scan or other standard ecotaxa .tsv files."
  },
  {
    "objectID": "info_general_ecotaxa-tsv-description.html",
    "href": "info_general_ecotaxa-tsv-description.html",
    "title": "Understanding zooplankton export files",
    "section": "",
    "text": "From ecotaxa, you export files of zooplankton data (large images). These come as .tsv files. In these files, there are a lot of data that can be a little overwhelming. However, all these columns host valuable data.\nIn general, all the columns of the .tsv file correspond to characteristics for each vignette.\nIf you export data directly from Ecotaxa, there will be metadata in the appropriate columns. For example each row has a value for the pixel to mm conversion. This is useful if you are working with Zooscan or Planktoscope data. Here, columns will be named based on what type of data are stored in it. There are ‘obj’ columns which correspond to things about the vignette. However, there are also columns related to the metadata like ‘acq’. It is a good idea to familarize yourself with what all these mean.\nHowever, if you export the data from ecopart,"
  },
  {
    "objectID": "info_updates-page.html",
    "href": "info_updates-page.html",
    "title": "Updates",
    "section": "",
    "text": "Created the quarto page to introduce the package and a short tutorial"
  },
  {
    "objectID": "info_updates-page.html#section-1",
    "href": "info_updates-page.html#section-1",
    "title": "Updates",
    "section": "4/20/22:",
    "text": "4/20/22:\n\nAdded several functions. Dedicated formatting to adders, modifiers, managers, and plotters"
  },
  {
    "objectID": "info_updates-page.html#section-2",
    "href": "info_updates-page.html#section-2",
    "title": "Updates",
    "section": "6/28/22:",
    "text": "6/28/22:\n\nPackage release to 1.0.0.9000 \nEcotaxaTools now uses a specific class paradigm which assigns objects a class structure. \nFrom a user perspective, this won’t be noticed largely. However, on the backend of the functions it makes things run smoothly. Now, the functions to interact with are primarily “pointers”. These direct datasets to class-specific functions. This allows for functions to function differently based input. This allows for a variety of workflows and will make scaling to include new features easier. For the time being, this might create new challenges for functions as things get worked out.\nAdded a uvp_par_conc and particle_plot features."
  },
  {
    "objectID": "info_updates-page.html#section-3",
    "href": "info_updates-page.html#section-3",
    "title": "Updates",
    "section": "8/10/22:",
    "text": "8/10/22:\n\nImproving documentation. Adding examples and example datasets"
  },
  {
    "objectID": "info_uvp_general-layout.html",
    "href": "info_uvp_general-layout.html",
    "title": "UVP General Structure",
    "section": "",
    "text": "ecopart_obj\n\n\n\nmeta\n\n\n\nzoo_list\n\n\n\nzoo_df\n\n\n\npar_list\n\n\n\npar_df\n\n\n\n\n\n\n\nThere are several main functions which can operate on the ecopart_obj for organizing data. These are referred to as querying, adding, modifying, and analysis functions. The first three are for manipulating and organizing an ecopart_obj. Analysis functions are used to take an ecopart_obj and transform it into new data structures and other analysis tools.\nThese functions are explained below:\n\nQuerying functions:\nThere functions are to get quick information from an ecopart objects\n\n\nAdding Functions:\nThese will add a column to all zoo_df files. However, they do not remove any data from the original data.\n\n\nModifying Functions:\nThese will modify the ecopart_obj and return a new ecopart_obj. These modify the data in some new way.\n\n\nAnalysis Functions:\nThese functions take an ecopart_obj and will produce new data structures with summary data. These are the link to most analysis products."
  },
  {
    "objectID": "man_uvp-merge-casts.html",
    "href": "man_uvp-merge-casts.html",
    "title": "Merging casts",
    "section": "",
    "text": "To merge casts, you must provide a name_map argument. This should be a list where each element of the list is a character vector with the casts to be merged. The names of the list items will be the new names of the casts. Note that this will merge both $zoo_files and $par_files. For Example:\n\nlibrary(EcotaxaTools)\n\n#merging casts based on station:\nname_map = list(\n    'gf' = ecopart_example$meta$profileid[which(ecopart_example$meta$stationid == 'gf')],\n    'other' = ecopart_example$meta$profileid[which(ecopart_example$meta$stationid != 'gf')]\n)\n\nmerged_obj <- ecopart_example |>\n    merge_casts(name_map = name_map)\n# now there's only two aggregate casts:\nnames(merged_obj$par_files)\n\n[1] \"gf\"    \"other\"\n\nnames(merged_obj$zoo_files)\n\n[1] \"gf\"    \"other\""
  },
  {
    "objectID": "man_uvp-modifiers.html",
    "href": "man_uvp-modifiers.html",
    "title": "Modifying Ecopart Objects",
    "section": "",
    "text": "add_zoo()\nTo add a new column, or replace an existing column, use add_zoo(). The two required arguments are func and col_name which specify the function to use and what to call the new column respectively. Additional agruments should be specified for the function being used after these are called.\nThere are several reasons why it might be useful to add or replace a column. For example: #### Adding biovolume for each particle To add a column for each zooplankton’s size you could use add_zoo(). Here, you can also use the biovolume() function from EcotaxaTools. See the details for it here\n\nlibrary(EcotaxaTools)\necopart_example <- ecopart_example |> add_zoo(func = biovolume, \n                                              col_name = 'biovol',\n                                              shape = 'ellipsoid',\n                                              pixel_mm = unique(ecopart_example$meta$acq_pixel))\n\necopart_example |> \n    get_all('biovol') |>\n    summary()\n\n    Min.  1st Qu.   Median     Mean  3rd Qu.     Max. \n    0.09     0.45     0.62    22.28     1.12 47530.85 \n\n\n\nReplacing taxonomic labels.\nTo replace taxonomic labels with other ones, you’ll likely want to replace the ‘name’ column. There are several ways to do this which are explained in the renaming page\n\n\n\nmod_zoo()\nTo selectively remove rows or summarize a zoo_df while still maintaining the ecopart_obj class, use mod_zoo(). Similar to add_zoo(), this function works like lapply() and takes a func argument. However, there is no need to name the new column because the return value should be a zoo_df.\nmod_zoo() is particularly useful for removing unwanted taxanomic categories see examples here, or other rows.\nFor example, you could use mod_zoo() to select a particular depth range of observations:\n\n#First define a function for the observations:\nget_mesopelagic_obsv <- function(df) {\n    row_index <- which(df$depth_including_offset > 200 & df$depth_including_offset < 1200)\n    if(length(row_index) == 0) {\n        return(NULL)\n    }\n    return(df[row_index, ])\n}\n\n# The use the function with mod_zoo()\nmidwater <- ecopart_example |> mod_zoo(func = get_mesopelagic_obsv)\n\n# observe the data:\nmidwater |> \n    get_all('depth_including_offset') |>\n    range()\n\n[1]  200.2 1199.6"
  },
  {
    "objectID": "man_uvp-renaming.html",
    "href": "man_uvp-renaming.html",
    "title": "Re-naming taxa in zoo files",
    "section": "",
    "text": "Renaming specific taxa\nIt could be the case you need to re-name a particular classification. For example, if you were working with a dataset where the annotator labeled something as ‘darksphere’ but you want these labeled as ‘feces’, you’ll want to re-classify this particular row without the functions described above. In the case you need to re-classify a particular taxa, you can rely on add_zoo() and a user-supplied function. Remember that to use add_zoo() you’ll need to have a function take in the zoo_df and return a vector (of length==nrow(df)). First, we can define a function for this task:\n\ndarksphere_to_feces <- function(df) {\n    orig_name <- df$name #get original names\n    orig_name[which(orig_name == 'darksphere')] <- 'feces' #re-classify just those names\n    return(orig_name) #return the modified \n}\n\nThen, this function can be compatible with the add_col() function. However, you’ll want to replace the $name column rather than create a new one:\n\necopart_example <- ecopart_example |>\n        add_zoo(darksphere_to_feces, 'name')"
  },
  {
    "objectID": "man_uvp-split-obj.html",
    "href": "man_uvp-split-obj.html",
    "title": "Splitting an ecopart_obj",
    "section": "",
    "text": "library(EcotaxaTools)\nsplit_objs <- ecopart_example |>\n    split_ecopart_obj(split_by = 'stationid')\n# this will produce 3 ecopart_objs\nnames(split_objs)\n\n[1] \"gf\" \"xx\" \"hs\""
  },
  {
    "objectID": "query_all-taxa.html",
    "href": "query_all-taxa.html",
    "title": "all_taxa()",
    "section": "",
    "text": "Likely, when using this function, it should be combined with unique().\n\nlibrary(EcotaxaTools)\necopart_example |>\n    all_taxa() |>\n    unique()\n\n [1] \"detritus\"                \"badfocus<artefact\"      \n [3] \"light<detritus\"          \"solitaryglobule\"        \n [5] \"tuff\"                    \"Eumalacostraca\"         \n [7] \"feces\"                   \"fiber<detritus\"         \n [9] \"Copepoda\"                \"Aulacanthidae\"          \n[11] \"puff\"                    \"Collodaria\"             \n[13] \"duplicate\"               \"Chaetognatha\"           \n[15] \"other<living\"            \"Rhizaria\"               \n[17] \"colonial<Rhizaria\"       \"Acantharea\"             \n[19] \"Aulosphaeridae\"          \"darksphere\"             \n[21] \"Ostracoda\"               \"Aulacantha\"             \n[23] \"Coelographis\"            \"Eucalanidae\"            \n[25] \"head<Chaetognatha\"       \"Castanellidae\"          \n[27] \"Coelodendridae\"          \"Actinopterygii\"         \n[29] \"Phaeodaria\"              \"temp circle\"            \n[31] \"tail<Chaetognatha\"       \"house\"                  \n[33] \"Crustacea\"               \"Foraminifera\"           \n[35] \"Medusettidae\"            \"Cnidaria<Hydrozoa\"      \n[37] \"Cnidaria<Metazoa\"        \"solitaryblack\"          \n[39] \"Pteropoda\"               \"Coelodendrum\"           \n[41] \"Ctenophora<Metazoa\"      \"colonial<Aulosphaeridae\"\n[43] \"Aulatractus\"             \"Alciopidae\"             \n[45] \"Pelagia\"                 \"artefact\"               \n[47] \"Siphonophorae\"           \"bubble\"                 \n[49] \"Poeobius\"                \"Annelida\"               \n[51] \"Cannosphaeridae\"         \"Salpida\""
  },
  {
    "objectID": "query_get-all.html",
    "href": "query_get-all.html",
    "title": "get_all()",
    "section": "",
    "text": "If you are interested in pulling just a\n\nWhat is the depth range of observations?\n\nlibrary(EcotaxaTools)\necopart_example |> \n    get_all('depth_including_offset') |>\n    range()\n\n[1]    2.9 3499.9\n\n\n\n\nWhat is the average size?\nWhen working with an ecopart_obj, all the size based metrics will still be in pixels, not mm. get_all() has an argument for converting pixels to mm. For this to work, you must provide an ecopart_obj, not just a zoo_list.\n\necopart_example |>\n    get_all('esd', pixel_conv = T) |>\n    mean()\n\n[1] 1.41243\n\n\n\n\nAdditional Info:\nWhen using, users must specify which column they are interested in querying from the zoo_df. If unfamiliar with these names you can access them by getting the column names of any single zoo_df\n\necopart_example$zoo_files$bats361_ctd1 |> \n    names()\n\n [1] \"orig_id\"                \"objid\"                  \"name\"                  \n [4] \"taxo_hierarchy\"         \"classif_qual\"           \"depth_including_offset\"\n [7] \"psampleid\"              \"%area\"                  \"angle\"                 \n[10] \"area\"                   \"area_exc\"               \"areai\"                 \n[13] \"bx\"                     \"by\"                     \"cdexc\"                 \n[16] \"centroids\"              \"circ.\"                  \"circex\"                \n[19] \"compentropy\"            \"compm1\"                 \"compm2\"                \n[22] \"compm3\"                 \"compmean\"               \"compslope\"             \n[25] \"convarea\"               \"convarea_area\"          \"convperim\"             \n[28] \"convperim_perim\"        \"cv\"                     \"elongation\"            \n[31] \"esd\"                    \"fcons\"                  \"feret\"                 \n[34] \"feretareaexc\"           \"fractal\"                \"height\"                \n[37] \"histcum1\"               \"histcum2\"               \"histcum3\"              \n[40] \"intden\"                 \"kurt\"                   \"kurt_mean\"             \n[43] \"major\"                  \"max\"                    \"mean\"                  \n[46] \"meanpos\"                \"median\"                 \"median_mean\"           \n[49] \"median_mean_range\"      \"min\"                    \"minor\"                 \n[52] \"mode\"                   \"nb1\"                    \"nb1_area\"              \n[55] \"nb1_range\"              \"nb2\"                    \"nb2_area\"              \n[58] \"nb2_range\"              \"nb3\"                    \"nb3_area\"              \n[61] \"nb3_range\"              \"perim.\"                 \"perimareaexc\"          \n[64] \"perimferet\"             \"perimmajor\"             \"range\"                 \n[67] \"skelarea\"               \"skeleton_area\"          \"skew\"                  \n[70] \"skew_mean\"              \"slope\"                  \"sr\"                    \n[73] \"stddev\"                 \"symetrieh\"              \"symetrieh_area\"        \n[76] \"symetriehc\"             \"symetriev\"              \"symetriev_area\"        \n[79] \"symetrievc\"             \"tag\"                    \"thickr\"                \n[82] \"width\"                  \"x\"                      \"xm\"                    \n[85] \"xmg5\"                   \"xstart\"                 \"y\"                     \n[88] \"ym\"                     \"ymg5\"                   \"ystart\""
  },
  {
    "objectID": "uvp_avg-concentration.html",
    "href": "uvp_avg-concentration.html",
    "title": "Averaging Concentration",
    "section": "",
    "text": "library(EcotaxaTools)\n# describe name map\nday_night_map <- list(\n    day = c('bats361_ctd1, bats361_ctd3', 'bats361_ctd5'),\n    night = c('bats361_ctd2', 'bats361_ctd4', 'bats361_ctd6')\n)\n\n#get average concentration for day & night of rhizaria taxa\navg_zoo_conc <- ecopart_example |> \n    mod_zoo(names_keep, keep_names = c('Acantharea','Phaeodaria','Foraminifera'), keep_children = T) |>\n    add_zoo(names_to, col_name = 'name', new_names = c('Acantharea','Phaeodaria','Foraminifera'), suppress_print = T) |>\n    uvp_zoo_conc(cast_name = c('bats361_ctd1', 'bats361_ctd3', 'bats361_ctd5',\n                               'bats361_ctd2', 'bats361_ctd4', 'bats361_ctd6'),\n                 breaks = c(0, 500, 100)) |>\n    average_casts(name_map = day_night_map) |>\n    lapply(bin_format)\n\navg_zoo_conc\n\n$day\n         db        group      mean sd min_d max_d    mp\n1   (0,100] Foraminifera 0.2183740  0     0   100  50.0\n2   (0,100]   Phaeodaria 0.2183740  0     0   100  50.0\n3 (100,500] Foraminifera 0.0000000  0   100   500 300.0\n4 (100,500]   Phaeodaria 0.4353050  0   100   500 300.0\n5 (500,517] Foraminifera 0.0000000  0   500   517 508.5\n6 (500,517]   Phaeodaria 0.6370644  0   500   517 508.5\n\n$night\n               db        group       mean        sd min_d max_d   mp\n1         (0,100]   Acantharea 0.24551351 0.2420503     0   100   50\n2         (0,100] Foraminifera 0.50519084 0.0000000     0   100   50\n3         (0,100]   Phaeodaria 0.88440932 0.3553993     0   100   50\n4       (100,500]   Acantharea 0.30365844 0.1184528   100   500  300\n5       (100,500] Foraminifera 0.00000000 0.0000000   100   500  300\n6       (100,500]   Phaeodaria 0.41411801 0.2147690   100   500  300\n7  (500,1.01e+03]   Acantharea 0.30333364 0.0000000   500  1010  755\n8  (500,1.01e+03]   Phaeodaria 0.83416750 0.0000000   500  1010  755\n9  (500,1.21e+03]   Acantharea 0.10717884 0.0000000   500  1210  855\n10 (500,1.21e+03] Foraminifera 0.00000000 0.0000000   500  1210  855\n11 (500,1.21e+03]   Phaeodaria 0.69666245 0.0000000   500  1210  855\n12  (500,3.5e+03]   Acantharea 0.06180172 0.0000000   500  3500 2000\n13  (500,3.5e+03]   Phaeodaria 0.21012584 0.0000000   500  3500 2000"
  },
  {
    "objectID": "uvp_integrate.html",
    "href": "uvp_integrate.html",
    "title": "Depth-integration",
    "section": "",
    "text": "Zooplankton concentration can be depth-integrated following either bin_taxa() or uvp_zoo_conc(). In EcotaxaTools, I provide a method for trapezoidal integration. This approach will use linear interpolation of the zooplankton concentration between mid-points of each depth bin. The core function is trap_integrate() which passes arguments to a linear interpolation function lin_interp() and to the base integrate() function. At times, integrate() will return errors from processing/accuracy. These can be circumvented by increaseing the number of subdivisions with subdivision (default is set to 100, typically I’ll increase to 1000L) or by increasing the rel.tol. By default rel.tol is set to .Machine$double.eps^25 and tolerance can be increased by changing that exponent.\nThere are a few ways to apply the integration tools:"
  },
  {
    "objectID": "uvp_integrate.html#integrating-a-single-dataframe-and-one-species",
    "href": "uvp_integrate.html#integrating-a-single-dataframe-and-one-species",
    "title": "Depth-integration",
    "section": "Integrating a single dataframe and one species:",
    "text": "Integrating a single dataframe and one species:\nIf there is a single zoo_df, and a single species, then the user must specify the columns manually. For example, if you were only interested in the Trichodesmium integrated biovolume from a single cast:\n\nlibrary(EcotaxaTools)\ntricho_only <- ecopart_example |>\n    mod_zoo(names_keep, keep_names = 'Trichodesmium', keep_children = T) |>\n    add_zoo(names_to, col_name = 'name', new_names = 'Trichodesmium', suppress_print = T) |>\n    add_zoo(func = biovolume, col_name = 'biovol', shape = 'ellipsoid', \n            pixel_mm = unique(ecopart_example$meta$acq_pixel)) |>\n    uvp_zoo_conc(func_col = 'biovol', func = sum, breaks = seq(0,400,25))\n\ntricho_c1 <- tricho_only[[1]] |>\n    bin_format() #get cast 1 only\n\n## Calculate trapzoidal integration\nintg_tricho = trap_integrate(x = tricho_c1$mp, y = tricho_c1$conc_m3,\n                              min_x = 0, max_x = 400)"
  },
  {
    "objectID": "uvp_integrate.html#integrating-mutliple-species-in-a-dataframe",
    "href": "uvp_integrate.html#integrating-mutliple-species-in-a-dataframe",
    "title": "Depth-integration",
    "section": "Integrating mutliple species in a dataframe:",
    "text": "Integrating mutliple species in a dataframe:\nFor multiple taxa, the integrate_all() will apply trap_integrate() for each unique taxa. This function also has an option for formatting, if bin_format() has yet to be applied. A list of integration dataframes for each taxa will be returned. To collapse this into a single df, use intg_to_tib(). For example, if you were interested in the integrated abundance of all crustaceans:\n\ncrustacea_conc <- ecopart_example |>\n    mod_zoo(names_keep, keep_names = 'Crustacea', keep_children = T) |>\n    uvp_zoo_conc(breaks = seq(0,1200,100))\n\ncrustacea_c1 <- crustacea_conc[[1]]\nintg_crustacea <- integrate_all(crustacea_c1, need_format = T)\nintg_crustacea |>\n    intg_to_tib()\n\n# A tibble: 2 × 2\n  taxa            intg\n  <chr>          <dbl>\n1 Copepoda        189.\n2 Eumalacostraca  324."
  },
  {
    "objectID": "uvp_integrate.html#integrating-multiple-taxa-across-several-casts",
    "href": "uvp_integrate.html#integrating-multiple-taxa-across-several-casts",
    "title": "Depth-integration",
    "section": "Integrating multiple taxa across several casts",
    "text": "Integrating multiple taxa across several casts\nMost useful for incorporation with the UVP / ecopart_obj framework would be to include integrate_all() with a lapply(). For example, using the crustacea_conc from the previous example:\n\ncrustacea_conc |>\n    lapply(integrate_all, need_format = T) |>\n    lapply(intg_to_tib) |>\n    list_to_tib('cast')\n\n# A tibble: 91 × 3\n   taxa             intg cast        \n   <chr>           <dbl> <chr>       \n 1 Copepoda        189.  bats361_ctd1\n 2 Eumalacostraca  324.  bats361_ctd1\n 3 Copepoda       1278.  bats361_ctd2\n 4 Crustacea        43.6 bats361_ctd2\n 5 Eucalanidae     201.  bats361_ctd2\n 6 Eumalacostraca   24.2 bats361_ctd2\n 7 Ostracoda       248.  bats361_ctd2\n 8 Copepoda       1093.  bats361_ctd3\n 9 Eucalanidae     430.  bats361_ctd3\n10 Eumalacostraca   80.4 bats361_ctd3\n# … with 81 more rows"
  },
  {
    "objectID": "uvp_par-concentration.html",
    "href": "uvp_par-concentration.html",
    "title": "Particle Concentration",
    "section": "",
    "text": "Warning\n\n\n\nAs of ver1.2.0.9000, the bulk of the EcotaxaTools functionality are primarily built toward zooplankton data. Particle functionality are limited but will improve with new updates. If you’d like to collaborate on this package, contact Alex Barth."
  },
  {
    "objectID": "uvp_par-concentration.html#calculate-the-particle-concentration-in-1-m-depth-bins",
    "href": "uvp_par-concentration.html#calculate-the-particle-concentration-in-1-m-depth-bins",
    "title": "Particle Concentration",
    "section": "Calculate the particle concentration in 1-m depth bins",
    "text": "Calculate the particle concentration in 1-m depth bins\nuvp_par_conc() can be used to quickly calculate the particle concentration in 1-m depth bins. The user must specify what sizes (by ESD) particles should be grouped. If left unspecified, the total particle concentration (regardless of size) will be returned.\nTo specify particle size classes use bin_limits. min_esd and max_esd can both be used to specify sizes.\n\nlibrary(EcotaxaTools)\n# in this list, there is a faulty cast at index 16\necopart_example$par_files <- ecopart_example$par_files[-16]\npar_conc <- ecopart_example |> uvp_par_conc(bin_limits = c(.1,.25,1,2)) # for three size classes\n\nThis now creates a list with particle concentrations for each cast. This data can all be combined with list_to_tib()\n\npar_conc |> list_to_tib('cast')\n\n# A tibble: 80,307 × 4\n   depth par_conc esd_bin    cast        \n   <dbl>    <dbl> <chr>      <chr>       \n 1     3    0.169 (0.1,0.25] bats361_ctd1\n 2     4    0.199 (0.1,0.25] bats361_ctd1\n 3     5    0.170 (0.1,0.25] bats361_ctd1\n 4     6    0.178 (0.1,0.25] bats361_ctd1\n 5     7    0.252 (0.1,0.25] bats361_ctd1\n 6     8    0.231 (0.1,0.25] bats361_ctd1\n 7     9    0.240 (0.1,0.25] bats361_ctd1\n 8    10    0.281 (0.1,0.25] bats361_ctd1\n 9    11    0.237 (0.1,0.25] bats361_ctd1\n10    12    0.332 (0.1,0.25] bats361_ctd1\n# … with 80,297 more rows"
  },
  {
    "objectID": "uvp_par-concentration.html#plotting-particle-concentraitons",
    "href": "uvp_par-concentration.html#plotting-particle-concentraitons",
    "title": "Particle Concentration",
    "section": "Plotting Particle concentraitons",
    "text": "Plotting Particle concentraitons\nThere is also a default plotting method for particle data. If you provide a par_list, ecopart_obj, or par_conc_list (from uvp_par_conc()), then the plots will open a new window for each. Providing a single dataframe (par_df) will produce single plots. Two plots can be made: \n\n\n\n\n\n\nNote\n\n\n\nIn the below examples, I feed the original par_df to the particle_plot() function. This will pass the data through uvp_par_conc(). However, you can also pass the output of uvp_par_conc() to particle_plot() if you wish to have that data separately available. For example: ex1 <- uvp_par_conc(); particle_plot(ex1$cast1).\n\n\n\nTotal particle concentration:\nIf there are no particle size bins, total particle concentration will be returned\n\nplot1 <- ecopart_example$par_files$bats361_ctd1 |>\n    particle_plot(img_vol = 1.1, pixel_mm = 0.092)\n\n`geom_smooth()` using method = 'loess' and formula 'y ~ x'\n\n\n\n\nprint(plot1)\n\n[1] \"Enjoy the plots!\"\n\n\n\n\nBinned particle concentration:\n\nplot2 <- ecopart_example$par_files$bats361_ctd1 |>\n    particle_plot(img_vol = 1.1, pixel_mm = 0.092,\n                  bin_limits = c(0.2,0.5,1))\n\n`geom_smooth()` using method = 'loess' and formula 'y ~ x'\n\n\n\n\nprint(plot2)\n\n[1] \"Enjoy the plots!\""
  },
  {
    "objectID": "uvp_zoo-concentration.html",
    "href": "uvp_zoo-concentration.html",
    "title": "Zooplankton Concentration",
    "section": "",
    "text": "A key feature of EcotaxaTools is easily getting the concentration of the zooplankton taxa from an ecopart_obj. This is done with uvp_zoo_conc(). You must provide an ecopart_obj as the first argument, then there is the option to specify which cast_name the calculation should be done on. This can be a single cast or multiple in a char vector. If not specified, it will be done on all casts. Finally, breaks must be provided as a numeric vector with limits on which to break. These should be the limits of each bin: breaks = c(0,200,1000) or breaks = seq(0,1200,10). Additionally, if a bin’s limits is outside the maximum range of observations, it will be trimmed to the maximum observation. There are additional arguments which can then be passed to bin_taxa(). For ecopart_obj, the applicable arguments are: - cat_col the category to bin by. Default is set to ‘name’, or the taxonomic labels. However, if there is a new column/labelling it can be set with this category. - func_col the column to apply the function to. Again by default this is ‘name’ but it could be changed if there is a need. For example, if there was a user-defined column for biomass it could be selected here - func the function to apply to func_col. Default is set to length. This is used rather than sum because bin_taxa() will count each observation of that category. However, if calculating the total biomass of each category, sum would be appropriate."
  },
  {
    "objectID": "uvp_zoo-concentration.html#getting-concentration-for-certain-taxa",
    "href": "uvp_zoo-concentration.html#getting-concentration-for-certain-taxa",
    "title": "Zooplankton Concentration",
    "section": "Getting concentration for certain taxa:",
    "text": "Getting concentration for certain taxa:\n\nlibrary(EcotaxaTools)\nzoo_conc <- ecopart_example |>\n    add_zoo(func = names_to, col_name = 'name', new_names = c('Chaetognatha','Copepoda','Eumalacostraca','living','not-living'), suppress_print = T) |> # rename for simplicity\n    mod_zoo(names_drop, drop_names = 'not-living') |> #remove detritus & artefact\n    uvp_zoo_conc(cast_name = c('bats361_ctd1', 'bats361_ctd2'), breaks = seq(0,1200,100)) |> # get concentration\n    lapply(bin_format) #formatting\n\n#take a peek:\nhead(zoo_conc$bats361_ctd1,8)\n\n         db          group   conc_m3 min_d max_d  mp\n1   (0,100]       Copepoda 1.1281843     0   100  50\n2   (0,100] Eumalacostraca 2.4820055     0   100  50\n3   (0,100]   Chaetognatha 0.4512737     0   100  50\n4   (0,100]         living 4.5127372     0   100  50\n5 (100,200]   Chaetognatha 0.4280089   100   200 150\n6 (100,200]       Copepoda 0.4280089   100   200 150\n7 (100,200] Eumalacostraca 0.4280089   100   200 150\n8 (100,200]         living 3.8520801   100   200 150\n\nhead(zoo_conc$bats361_ctd2,8)\n\n         db          group   conc_m3 min_d max_d  mp\n1   (0,100]   Chaetognatha 0.2419726     0   100  50\n2   (0,100]       Copepoda 1.2098628     0   100  50\n3   (0,100] Eumalacostraca 0.2419726     0   100  50\n4   (0,100]         living 6.2912866     0   100  50\n5 (100,200]   Chaetognatha 0.9084096   100   200 150\n6 (100,200]       Copepoda 1.5897168   100   200 150\n7 (100,200]         living 9.0840960   100   200 150\n8 (100,200] Eumalacostraca 0.0000000   100   200 150"
  },
  {
    "objectID": "uvp_zoo-concentration.html#calcuting-biovolume-concentration",
    "href": "uvp_zoo-concentration.html#calcuting-biovolume-concentration",
    "title": "Zooplankton Concentration",
    "section": "Calcuting biovolume concentration:",
    "text": "Calcuting biovolume concentration:\nLet’s say you were interested in getting the volumetric concentration of all copepods for a single cast:\n\ncast1_copepod_conc <- ecopart_example |>\n    mod_zoo(names_keep, keep_names = 'Copepoda', keep_children = T) |>\n    add_zoo(func = names_to, col_name = 'name', new_names = 'Copepoda', suppress_print = T) |>\n    add_zoo(func = biovolume, col_name = 'biovol', shape = 'ellipsoid', pixel_mm = unique(ecopart_example$meta$acq_pixel)) |>\n    uvp_zoo_conc(cast_name = 'bats361_ctd12', breaks = seq(0,500,100), \n                 func_col = 'biovol', func = sum) |>\n    bin_format()\n\ncast1_copepod_conc\n\n         db    group   conc_m3 min_d max_d  mp\n1   (0,100] Copepoda 0.3706134     0   100  50\n2 (100,200] Copepoda 0.7869312   100   200 150\n3 (200,300] Copepoda 0.0000000   200   300 250\n4 (300,400] Copepoda 0.0000000   300   400 350\n5 (400,500] Copepoda 1.6664027   400   500 450\n\n\nThere are several more options on how this feature can be used and customized for different projects. Look into the structure of bin_taxa() to futher understand this process. Additionally feel free to discuss any questions with Alex Barth."
  }
]